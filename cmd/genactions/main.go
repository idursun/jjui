package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"unicode"
)

type bindRule struct {
	Owner  string
	Action string
	Intent string
	Set    map[string]string
}

type intentTypeMeta struct {
	Fields map[string]string
}

type enumValueMeta struct {
	ConstName string
	Literal   string
}

type parsedRule struct {
	Rule bindRule
	Errs []error
}

var (
	ownerSegmentPattern = regexp.MustCompile(`^[a-z0-9_]+$`)
	actionPattern       = regexp.MustCompile(`^[a-z0-9_]+$`)
)

func main() {
	repoRoot, err := findRepoRoot()
	if err != nil {
		fmt.Fprintf(os.Stderr, "find repo root: %v\n", err)
		os.Exit(1)
	}

	intents, err := collectIntentTypeMeta(filepath.Join(repoRoot, "internal/ui/intents"))
	if err != nil {
		fmt.Fprintf(os.Stderr, "collect intent metadata: %v\n", err)
		os.Exit(1)
	}
	enums, err := collectEnumTypeMeta(filepath.Join(repoRoot, "internal/ui/intents"))
	if err != nil {
		fmt.Fprintf(os.Stderr, "collect enum metadata: %v\n", err)
		os.Exit(1)
	}

	rules, err := collectBindRules(filepath.Join(repoRoot, "internal/ui/intents"))
	if err != nil {
		fmt.Fprintf(os.Stderr, "collect bind rules: %v\n", err)
		os.Exit(1)
	}

	if err := validateRules(rules, intents, enums); err != nil {
		fmt.Fprintf(os.Stderr, "validate bind rules: %v\n", err)
		os.Exit(1)
	}
	actionIDs := deriveActionIDs(rules)

	actionArgSchemas, actionRequiredArgs, err := deriveActionArgSchemas(rules, intents, enums)
	if err != nil {
		fmt.Fprintf(os.Stderr, "derive action arg schemas: %v\n", err)
		os.Exit(1)
	}
	actionOwners := deriveActionOwners(rules)
	if err := validateActionMetadata(actionIDs, actionOwners); err != nil {
		fmt.Fprintf(os.Stderr, "validate action metadata: %v\n", err)
		os.Exit(1)
	}

	src, err := generateCatalogSource(rules, actionIDs, intents, enums)
	if err != nil {
		fmt.Fprintf(os.Stderr, "generate catalog: %v\n", err)
		os.Exit(1)
	}
	if err := os.WriteFile(filepath.Join(repoRoot, "internal/ui/actions/catalog_gen.go"), src, 0o644); err != nil {
		fmt.Fprintf(os.Stderr, "write generated file: %v\n", err)
		os.Exit(1)
	}

	meta, err := generateActionMetaSource(actionIDs, actionArgSchemas, actionRequiredArgs, actionOwners)
	if err != nil {
		fmt.Fprintf(os.Stderr, "generate action meta: %v\n", err)
		os.Exit(1)
	}
	actionMetaDir := filepath.Join(repoRoot, "internal/ui/actionmeta")
	if err := os.MkdirAll(actionMetaDir, 0o755); err != nil {
		fmt.Fprintf(os.Stderr, "mkdir actionmeta: %v\n", err)
		os.Exit(1)
	}
	if err := os.WriteFile(filepath.Join(actionMetaDir, "builtins_gen.go"), meta, 0o644); err != nil {
		fmt.Fprintf(os.Stderr, "write action meta file: %v\n", err)
		os.Exit(1)
	}
}

func findRepoRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", errors.New("go.mod not found in current directory or parents")
		}
		dir = parent
	}
}

func generateCatalogSource(rules []bindRule, actionIDs []string, intents map[string]intentTypeMeta, enums map[string][]enumValueMeta) ([]byte, error) {
	owners := uniqueOwners(rules)
	revisionsOwners := revisionsOwnerList(owners)
	ownerRules := rulesByOwner(rules)
	useBoolArg := rulesUseBoolArgs(rules)

	var b bytes.Buffer
	b.WriteString("// Code generated by cmd/genactions; DO NOT EDIT.\n")
	b.WriteString("package actions\n\n")
	b.WriteString("import (\n")
	b.WriteString("\tkeybindings \"github.com/idursun/jjui/internal/ui/bindings\"\n")
	b.WriteString("\t\"github.com/idursun/jjui/internal/ui/intents\"\n")
	if useBoolArg {
		b.WriteString("\t\"github.com/idursun/jjui/internal/ui/actionargs\"\n")
	}
	b.WriteString(")\n\n")

	b.WriteString("const (\n")
	usedConstNames := map[string]struct{}{}
	for _, owner := range owners {
		b.WriteString(fmt.Sprintf("\t%s = %q\n", ownerConst(owner), owner))
	}
	b.WriteString("\n")
	for _, actionID := range actionIDs {
		name := actionConst(actionID)
		usedConstNames[name] = struct{}{}
		b.WriteString(fmt.Sprintf("\t%s keybindings.Action = %q\n", name, actionID))
	}
	b.WriteString(")\n\n")

	b.WriteString("func IsRevisionsOwner(owner string) bool {\n")
	b.WriteString("\tswitch owner {\n")
	if len(revisionsOwners) > 0 {
		b.WriteString("\tcase ")
		for i, owner := range revisionsOwners {
			if i > 0 {
				b.WriteString(", ")
			}
			b.WriteString(ownerConst(owner))
		}
		b.WriteString(":\n")
		b.WriteString("\t\treturn true\n")
	}
	b.WriteString("\tdefault:\n")
	b.WriteString("\t\treturn false\n")
	b.WriteString("\t}\n")
	b.WriteString("}\n\n")

	b.WriteString("func ResolveIntent(owner string, action keybindings.Action, args map[string]any) (intents.Intent, bool) {\n")
	b.WriteString("\tswitch owner {\n")
	for _, owner := range owners {
		b.WriteString(fmt.Sprintf("\tcase %s:\n", ownerConst(owner)))
		b.WriteString("\t\tswitch action {\n")
		for _, r := range ownerRules[owner] {
			b.WriteString(fmt.Sprintf("\t\tcase keybindings.Action(%q):\n\t\t\treturn %s, true\n", canonicalActionID(owner, r.Action), buildIntentExpr(r, intents, enums)))
		}
		b.WriteString("\t\t}\n")
	}
	b.WriteString("\t}\n")
	b.WriteString("\treturn nil, false\n")
	b.WriteString("}\n\n")

	for _, enumType := range sortedEnumTypesUsedByRules(rules, intents, enums) {
		b.WriteString(fmt.Sprintf("func enumArg%s(args map[string]any, name string) intents.%s {\n", toCamel(enumType), enumType))
		b.WriteString(fmt.Sprintf("\tvar zero intents.%s\n", enumType))
		b.WriteString("\tif args == nil {\n\t\treturn zero\n\t}\n")
		b.WriteString("\tv, ok := args[name]\n\tif !ok {\n\t\treturn zero\n\t}\n")
		b.WriteString("\ts, ok := v.(string)\n\tif !ok {\n\t\treturn zero\n\t}\n")
		b.WriteString("\tswitch s {\n")
		for _, val := range enums[enumType] {
			b.WriteString(fmt.Sprintf("\tcase %q:\n\t\treturn intents.%s\n", val.Literal, val.ConstName))
		}
		b.WriteString("\tdefault:\n\t\treturn zero\n\t}\n")
		b.WriteString("}\n\n")
	}

	src, err := format.Source(b.Bytes())
	if err != nil {
		return nil, fmt.Errorf("format generated source: %w\n%s", err, b.String())
	}
	return src, nil
}

func sharedTargetPickerPattern(owners []string, ownerRules map[string][]bindRule, intents map[string]intentTypeMeta, enums map[string][]enumValueMeta) ([]string, []bindRule, bool) {
	var targetPickerOwners []string
	for _, owner := range owners {
		if strings.HasSuffix(owner, ".target_picker") {
			targetPickerOwners = append(targetPickerOwners, owner)
		}
	}
	if len(targetPickerOwners) < 2 {
		return nil, nil, false
	}

	baseOwner := targetPickerOwners[0]
	baseRules := ownerRules[baseOwner]
	baseExprs := make(map[string]string, len(baseRules))
	for _, r := range baseRules {
		baseExprs[r.Action] = buildIntentExpr(r, intents, enums)
	}

	for _, owner := range targetPickerOwners[1:] {
		rules := ownerRules[owner]
		if len(rules) != len(baseRules) {
			return nil, nil, false
		}
		for _, r := range rules {
			expr, ok := baseExprs[r.Action]
			if !ok || expr != buildIntentExpr(r, intents, enums) {
				return nil, nil, false
			}
		}
	}

	return targetPickerOwners, append([]bindRule(nil), baseRules...), true
}

func generateActionMetaSource(actionIDs []string, actionArgSchemas map[string]map[string]string, actionRequiredArgs map[string][]string, actionOwners map[string][]string) ([]byte, error) {
	var b bytes.Buffer
	b.WriteString("// Code generated by cmd/genactions; DO NOT EDIT.\n")
	b.WriteString("package actionmeta\n\n")
	b.WriteString("import (\n")
	b.WriteString("\t\"fmt\"\n")
	b.WriteString("\t\"strings\"\n")
	b.WriteString(")\n\n")

	b.WriteString("type ActionMetadata struct {\n")
	b.WriteString("\tAction string\n")
	b.WriteString("\tOwners []string\n")
	b.WriteString("\tArgs map[string]string\n")
	b.WriteString("}\n\n")

	b.WriteString("var builtInActions = map[string]struct{}{\n")
	for _, action := range actionIDs {
		b.WriteString(fmt.Sprintf("\t%q: {},\n", action))
	}
	b.WriteString("}\n\n")

	b.WriteString("var builtInActionOwners = map[string][]string{\n")
	ownerActionNames := make([]string, 0, len(actionOwners))
	for action := range actionOwners {
		ownerActionNames = append(ownerActionNames, action)
	}
	sort.Strings(ownerActionNames)
	for _, action := range ownerActionNames {
		b.WriteString(fmt.Sprintf("\t%q: {", action))
		for i, owner := range actionOwners[action] {
			if i > 0 {
				b.WriteString(", ")
			}
			b.WriteString(fmt.Sprintf("%q", owner))
		}
		b.WriteString("},\n")
	}
	b.WriteString("}\n\n")

	b.WriteString("var builtInActionArgSchemas = map[string]map[string]string{\n")
	actionNames := make([]string, 0, len(actionArgSchemas))
	for action := range actionArgSchemas {
		actionNames = append(actionNames, action)
	}
	sort.Strings(actionNames)
	for _, action := range actionNames {
		schema := actionArgSchemas[action]
		b.WriteString(fmt.Sprintf("\t%q: {\n", action))
		argNames := make([]string, 0, len(schema))
		for arg := range schema {
			argNames = append(argNames, arg)
		}
		sort.Strings(argNames)
		for _, arg := range argNames {
			b.WriteString(fmt.Sprintf("\t\t%q: %q,\n", arg, schema[arg]))
		}
		b.WriteString("\t},\n")
	}
	b.WriteString("}\n\n")

	b.WriteString("var builtInActionRequiredArgs = map[string][]string{\n")
	requiredActionNames := make([]string, 0, len(actionRequiredArgs))
	for action := range actionRequiredArgs {
		requiredActionNames = append(requiredActionNames, action)
	}
	sort.Strings(requiredActionNames)
	for _, action := range requiredActionNames {
		b.WriteString(fmt.Sprintf("\t%q: {", action))
		for i, arg := range actionRequiredArgs[action] {
			if i > 0 {
				b.WriteString(", ")
			}
			b.WriteString(fmt.Sprintf("%q", arg))
		}
		b.WriteString("},\n")
	}
	b.WriteString("}\n\n")

	b.WriteString("var builtInActionOrder = []string{\n")
	for _, action := range actionIDs {
		b.WriteString(fmt.Sprintf("\t%q,\n", action))
	}
	b.WriteString("}\n\n")

	b.WriteString("func ActionOwners(action string) []string {\n")
	b.WriteString("\taction = strings.TrimSpace(action)\n")
	b.WriteString("\towners, ok := builtInActionOwners[action]\n")
	b.WriteString("\tif !ok {\n\t\treturn nil\n\t}\n")
	b.WriteString("\treturn append([]string(nil), owners...)\n")
	b.WriteString("}\n\n")

	b.WriteString("func ActionMetadataFor(action string) (ActionMetadata, bool) {\n")
	b.WriteString("\taction = strings.TrimSpace(action)\n")
	b.WriteString("\tif !IsBuiltInAction(action) {\n")
	b.WriteString("\t\treturn ActionMetadata{}, false\n")
	b.WriteString("\t}\n")
	b.WriteString("\tmeta := ActionMetadata{\n")
	b.WriteString("\t\tAction: action,\n")
	b.WriteString("\t\tOwners: ActionOwners(action),\n")
	b.WriteString("\t}\n")
	b.WriteString("\tif schema, ok := builtInActionArgSchemas[action]; ok {\n")
	b.WriteString("\t\tmeta.Args = make(map[string]string, len(schema))\n")
	b.WriteString("\t\tfor k, v := range schema {\n")
	b.WriteString("\t\t\tmeta.Args[k] = v\n")
	b.WriteString("\t\t}\n")
	b.WriteString("\t}\n")
	b.WriteString("\treturn meta, true\n")
	b.WriteString("}\n\n")

	b.WriteString("func BuiltInActions() []string {\n")
	b.WriteString("\tout := make([]string, len(builtInActionOrder))\n")
	b.WriteString("\tcopy(out, builtInActionOrder)\n")
	b.WriteString("\treturn out\n")
	b.WriteString("}\n\n")

	b.WriteString("func IsBuiltInAction(action string) bool {\n")
	b.WriteString("\taction = strings.TrimSpace(action)\n")
	b.WriteString("\t_, ok := builtInActions[action]\n")
	b.WriteString("\treturn ok\n")
	b.WriteString("}\n\n")

	b.WriteString("func ValidateBuiltInActionArgs(action string, args map[string]any) error {\n")
	b.WriteString("\taction = strings.TrimSpace(action)\n")
	b.WriteString("\tif !IsBuiltInAction(action) {\n")
	b.WriteString("\t\treturn fmt.Errorf(\"unknown built-in action %q\", action)\n")
	b.WriteString("\t}\n")
	b.WriteString("\tschema := builtInActionArgSchemas[action]\n")
	b.WriteString("\tfor _, required := range builtInActionRequiredArgs[action] {\n")
	b.WriteString("\t\tif _, ok := args[required]; !ok {\n")
	b.WriteString("\t\t\treturn fmt.Errorf(\"action %q requires arg %q\", action, required)\n")
	b.WriteString("\t\t}\n")
	b.WriteString("\t}\n")
	b.WriteString("\tfor key, value := range args {\n")
	b.WriteString("\t\texpectedType, ok := schema[key]\n")
	b.WriteString("\t\tif !ok {\n")
	b.WriteString("\t\t\treturn fmt.Errorf(\"action %q does not accept arg %q\", action, key)\n")
	b.WriteString("\t\t}\n")
	b.WriteString("\t\tswitch expectedType {\n")
	b.WriteString("\t\tcase \"bool\":\n")
	b.WriteString("\t\t\tif _, ok := value.(bool); !ok {\n")
	b.WriteString("\t\t\t\treturn fmt.Errorf(\"action %q arg %q expects bool\", action, key)\n")
	b.WriteString("\t\t\t}\n")
	b.WriteString("\t\tdefault:\n")
	b.WriteString("\t\t\tif strings.HasPrefix(expectedType, \"enum:\") {\n")
	b.WriteString("\t\t\t\ts, ok := value.(string)\n")
	b.WriteString("\t\t\t\tif !ok {\n")
	b.WriteString("\t\t\t\t\treturn fmt.Errorf(\"action %q arg %q expects string enum\", action, key)\n")
	b.WriteString("\t\t\t\t}\n")
	b.WriteString("\t\t\t\tallowed := strings.Split(strings.TrimPrefix(expectedType, \"enum:\"), \"|\")\n")
	b.WriteString("\t\t\t\tvalid := false\n")
	b.WriteString("\t\t\t\tfor _, item := range allowed {\n")
	b.WriteString("\t\t\t\t\tif s == item {\n")
	b.WriteString("\t\t\t\t\t\tvalid = true\n")
	b.WriteString("\t\t\t\t\t\tbreak\n")
	b.WriteString("\t\t\t\t\t}\n")
	b.WriteString("\t\t\t\t}\n")
	b.WriteString("\t\t\t\tif !valid {\n")
	b.WriteString("\t\t\t\t\treturn fmt.Errorf(\"action %q arg %q invalid value %q (accepted: %s)\", action, key, s, strings.Join(allowed, \", \"))\n")
	b.WriteString("\t\t\t\t}\n")
	b.WriteString("\t\t\t\tcontinue\n")
	b.WriteString("\t\t\t}\n")
	b.WriteString("\t\t\treturn fmt.Errorf(\"action %q arg %q has unsupported expected type %q\", action, key, expectedType)\n")
	b.WriteString("\t\t}\n")
	b.WriteString("\t}\n")
	b.WriteString("\treturn nil\n")
	b.WriteString("}\n")

	src, err := format.Source(b.Bytes())
	if err != nil {
		return nil, fmt.Errorf("format generated actionmeta source: %w\n%s", err, b.String())
	}
	return src, nil
}

func collectBindRules(dir string) ([]bindRule, error) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}
	pkg, ok := pkgs["intents"]
	if !ok {
		return nil, fmt.Errorf("intents package not found in %s", dir)
	}

	var paths []string
	for path := range pkg.Files {
		paths = append(paths, path)
	}
	sort.Strings(paths)

	var out []bindRule
	seen := map[string]struct{}{}
	var errs []string

	for _, path := range paths {
		file := pkg.Files[path]
		for _, decl := range file.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}
			for _, spec := range gen.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				doc := ts.Doc
				if doc == nil {
					doc = gen.Doc
				}
				if doc == nil {
					continue
				}
				parsed := parseBindDirectives(doc, ts.Name.Name)
				for _, pr := range parsed {
					for _, e := range pr.Errs {
						errs = append(errs, fmt.Sprintf("%s: %v", filepath.Base(path), e))
					}
					if pr.Rule.Owner == "" || pr.Rule.Action == "" {
						continue
					}
					key := pr.Rule.Owner + "|" + pr.Rule.Action
					if _, ok := seen[key]; ok {
						errs = append(errs, fmt.Sprintf("%s: duplicate binding for scope=%q action=%q", filepath.Base(path), pr.Rule.Owner, pr.Rule.Action))
						continue
					}
					seen[key] = struct{}{}
					out = append(out, pr.Rule)
				}
			}
		}
	}

	if len(errs) > 0 {
		return nil, errors.New(strings.Join(errs, "; "))
	}

	sort.Slice(out, func(i, j int) bool {
		if out[i].Owner != out[j].Owner {
			return out[i].Owner < out[j].Owner
		}
		if out[i].Action != out[j].Action {
			return out[i].Action < out[j].Action
		}
		return out[i].Intent < out[j].Intent
	})
	return out, nil
}

func parseBindDirectives(doc *ast.CommentGroup, intentType string) []parsedRule {
	var out []parsedRule
	for _, c := range doc.List {
		line := strings.TrimSpace(strings.TrimPrefix(c.Text, "//"))
		if !strings.HasPrefix(line, "jjui:bind") {
			continue
		}
		rest := strings.TrimSpace(strings.TrimPrefix(line, "jjui:bind"))
		parts := strings.Fields(rest)
		rule := bindRule{Intent: intentType, Set: map[string]string{}}
		var errs []error

		for _, part := range parts {
			kv := strings.SplitN(part, "=", 2)
			if len(kv) != 2 {
				errs = append(errs, fmt.Errorf("invalid token %q in directive %q", part, line))
				continue
			}
			k := strings.TrimSpace(kv[0])
			v := strings.TrimSpace(kv[1])
			switch k {
			case "scope":
				rule.Owner = v
			case "action":
				rule.Action = v
			case "set":
				for _, assign := range strings.Split(v, ",") {
					fv := strings.SplitN(assign, ":", 2)
					if len(fv) != 2 {
						errs = append(errs, fmt.Errorf("invalid set assignment %q in directive %q", assign, line))
						continue
					}
					field := strings.TrimSpace(fv[0])
					value := strings.TrimSpace(fv[1])
					if field == "" || value == "" {
						errs = append(errs, fmt.Errorf("invalid set assignment %q in directive %q", assign, line))
						continue
					}
					if _, exists := rule.Set[field]; exists {
						errs = append(errs, fmt.Errorf("duplicate set field %q in directive %q", field, line))
						continue
					}
					rule.Set[field] = value
				}
			default:
				errs = append(errs, fmt.Errorf("unknown directive key %q in %q", k, line))
			}
		}

		if rule.Owner == "" {
			errs = append(errs, fmt.Errorf("missing scope in directive %q", line))
		}
		if rule.Action == "" {
			errs = append(errs, fmt.Errorf("missing action in directive %q", line))
		}

		out = append(out, parsedRule{Rule: rule, Errs: errs})
	}
	return out
}

func collectIntentTypeMeta(dir string) (map[string]intentTypeMeta, error) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}
	pkg, ok := pkgs["intents"]
	if !ok {
		return nil, fmt.Errorf("intents package not found in %s", dir)
	}

	meta := map[string]intentTypeMeta{}
	for _, file := range pkg.Files {
		for _, decl := range file.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}
			for _, spec := range gen.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				fields := map[string]string{}
				if st, ok := ts.Type.(*ast.StructType); ok {
					for _, f := range st.Fields.List {
						ft := exprTypeName(f.Type)
						for _, n := range f.Names {
							fields[n.Name] = ft
						}
					}
				}
				meta[ts.Name.Name] = intentTypeMeta{Fields: fields}
			}
		}
	}
	return meta, nil
}

func collectEnumTypeMeta(dir string) (map[string][]enumValueMeta, error) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}
	pkg, ok := pkgs["intents"]
	if !ok {
		return nil, fmt.Errorf("intents package not found in %s", dir)
	}

	out := map[string][]enumValueMeta{}
	for _, file := range pkg.Files {
		for _, decl := range file.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.CONST {
				continue
			}
			var currentType string
			for _, spec := range gen.Specs {
				vs, ok := spec.(*ast.ValueSpec)
				if !ok || len(vs.Names) == 0 {
					continue
				}
				if vs.Type != nil {
					if ident, ok := vs.Type.(*ast.Ident); ok {
						currentType = ident.Name
					} else {
						currentType = ""
					}
				}
				if currentType == "" {
					continue
				}
				for _, name := range vs.Names {
					out[currentType] = append(out[currentType], enumValueMeta{
						ConstName: name.Name,
						Literal:   enumLiteral(currentType, name.Name),
					})
				}
			}
		}
	}
	return out, nil
}

func deriveActionIDs(rules []bindRule) []string {
	seen := map[string]struct{}{}
	actions := make([]string, 0, len(rules))
	for _, rule := range rules {
		fullID := canonicalActionID(rule.Owner, rule.Action)
		if _, ok := seen[fullID]; ok {
			continue
		}
		seen[fullID] = struct{}{}
		actions = append(actions, fullID)
	}
	sort.Strings(actions)
	return actions
}

func deriveActionArgSchemas(rules []bindRule, intents map[string]intentTypeMeta, enums map[string][]enumValueMeta) (map[string]map[string]string, map[string][]string, error) {
	out := map[string]map[string]string{}
	required := map[string]map[string]struct{}{}
	for _, rule := range rules {
		intent, ok := intents[rule.Intent]
		if !ok {
			continue
		}
		for field, value := range rule.Set {
			fieldType, ok := intent.Fields[field]
			if !ok {
				continue
			}
			argName, argType, argRequired, ok := parseArgRef(fieldType, value, enums)
			if !ok {
				continue
			}
			fullID := canonicalActionID(rule.Owner, rule.Action)
			if out[fullID] == nil {
				out[fullID] = map[string]string{}
			}
			if existing, exists := out[fullID][argName]; exists && existing != argType {
				merged, ok := mergeArgTypes(existing, argType)
				if !ok {
					return nil, nil, fmt.Errorf("action %q arg %q has conflicting types %q and %q", fullID, argName, existing, argType)
				}
				out[fullID][argName] = merged
				continue
			}
			out[fullID][argName] = argType
			if argRequired {
				if required[fullID] == nil {
					required[fullID] = map[string]struct{}{}
				}
				required[fullID][argName] = struct{}{}
			}
		}
	}

	requiredOut := map[string][]string{}
	for action, requiredSet := range required {
		args := make([]string, 0, len(requiredSet))
		for arg := range requiredSet {
			args = append(args, arg)
		}
		sort.Strings(args)
		requiredOut[action] = args
	}
	return out, requiredOut, nil
}

func mergeArgTypes(a, b string) (string, bool) {
	if a == b {
		return a, true
	}
	if !strings.HasPrefix(a, "enum:") || !strings.HasPrefix(b, "enum:") {
		return "", false
	}
	seen := map[string]struct{}{}
	var merged []string
	for _, item := range append(strings.Split(strings.TrimPrefix(a, "enum:"), "|"), strings.Split(strings.TrimPrefix(b, "enum:"), "|")...) {
		if item == "" {
			continue
		}
		if _, ok := seen[item]; ok {
			continue
		}
		seen[item] = struct{}{}
		merged = append(merged, item)
	}
	return "enum:" + strings.Join(merged, "|"), true
}

func deriveActionOwners(rules []bindRule) map[string][]string {
	owners := map[string]map[string]struct{}{}
	for _, rule := range rules {
		fullID := canonicalActionID(rule.Owner, rule.Action)
		if owners[fullID] == nil {
			owners[fullID] = map[string]struct{}{}
		}
		owners[fullID][rule.Owner] = struct{}{}
	}

	out := map[string][]string{}
	for action, ownerSet := range owners {
		list := make([]string, 0, len(ownerSet))
		for owner := range ownerSet {
			list = append(list, owner)
		}
		sort.Strings(list)
		out[action] = list
	}
	return out
}

func validateRules(rules []bindRule, intents map[string]intentTypeMeta, enums map[string][]enumValueMeta) error {
	var errs []string
	seenFullIDs := map[string]struct{}{}
	for _, rule := range rules {
		if err := validateOwnerFormat(rule.Owner); err != nil {
			errs = append(errs, fmt.Sprintf("invalid owner %q: %v", rule.Owner, err))
		}
		if err := validateActionFormat(rule.Action); err != nil {
			errs = append(errs, fmt.Sprintf("invalid action %q: %v", rule.Action, err))
		}
		fullID := canonicalActionID(rule.Owner, rule.Action)
		if _, ok := seenFullIDs[fullID]; ok {
			errs = append(errs, fmt.Sprintf("duplicate full action id %q", fullID))
		} else {
			seenFullIDs[fullID] = struct{}{}
		}
		intent, ok := intents[rule.Intent]
		if !ok {
			errs = append(errs, fmt.Sprintf("unknown intent type %q for owner=%q action=%q", rule.Intent, rule.Owner, rule.Action))
			continue
		}
		for field, value := range rule.Set {
			fieldType, ok := intent.Fields[field]
			if !ok {
				errs = append(errs, fmt.Sprintf("unknown field %q on intent %q (owner=%q action=%q)", field, rule.Intent, rule.Owner, rule.Action))
				continue
			}
			if err := validateSetValueType(fieldType, value, enums); err != nil {
				errs = append(errs, fmt.Sprintf("invalid set value for %s.%s (%s): %v", rule.Intent, field, rule.Action, err))
			}
		}
	}
	if len(errs) > 0 {
		return errors.New(strings.Join(errs, "; "))
	}
	return nil
}

func validateOwnerFormat(owner string) error {
	if owner == "" {
		return errors.New("owner is empty")
	}
	segments := strings.Split(owner, ".")
	for _, segment := range segments {
		if segment == "" {
			return errors.New("owner has empty segment")
		}
		if !ownerSegmentPattern.MatchString(segment) {
			return fmt.Errorf("owner segment %q must match [a-z0-9_]+", segment)
		}
	}
	return nil
}

func validateActionFormat(action string) error {
	if action == "" {
		return errors.New("action is empty")
	}
	if strings.Contains(action, ".") {
		return errors.New("action cannot contain dots")
	}
	if !actionPattern.MatchString(action) {
		return errors.New("action must match [a-z0-9_]+")
	}
	return nil
}

func canonicalActionID(owner, action string) string {
	return owner + "." + action
}

func validateActionMetadata(actionIDs []string, actionOwners map[string][]string) error {
	var errs []string
	for _, action := range actionIDs {
		if len(actionOwners[action]) == 0 {
			errs = append(errs, fmt.Sprintf("action %q has no owners", action))
		}
	}
	if len(errs) > 0 {
		return errors.New(strings.Join(errs, "; "))
	}
	return nil
}

func validateSetValueType(fieldType, value string, enums map[string][]enumValueMeta) error {
	switch fieldType {
	case "bool":
		if value == "true" || value == "false" || isBoolArg(value) {
			return nil
		}
		return fmt.Errorf("expected bool or $bool(...), got %q", value)
	case "int":
		if _, err := strconv.Atoi(value); err == nil {
			return nil
		}
		return fmt.Errorf("expected int, got %q", value)
	case "string":
		if strings.HasPrefix(value, "\"") && strings.HasSuffix(value, "\"") {
			return nil
		}
		return fmt.Errorf("expected quoted string, got %q", value)
	default:
		if argName, ok := parseEnumArg(value); ok {
			if len(enums[fieldType]) == 0 {
				return fmt.Errorf("expected identifier for %q, got %q", fieldType, value)
			}
			if strings.TrimSpace(argName) == "" {
				return fmt.Errorf("invalid enum arg %q", value)
			}
			return nil
		}
		if isIdentifier(value) {
			return nil
		}
		return fmt.Errorf("expected identifier for %q, got %q", fieldType, value)
	}
}

func exprTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		if pkg, ok := t.X.(*ast.Ident); ok {
			return pkg.Name + "." + t.Sel.Name
		}
		return t.Sel.Name
	default:
		return fmt.Sprintf("%T", expr)
	}
}

func isBoolArg(value string) bool {
	return strings.HasPrefix(value, "$bool(") && strings.HasSuffix(value, ")")
}

func parseArgRef(fieldType, value string, enums map[string][]enumValueMeta) (name string, typ string, required bool, ok bool) {
	if isBoolArg(value) {
		name := strings.TrimSuffix(strings.TrimPrefix(value, "$bool("), ")")
		if name == "" {
			return "", "", false, false
		}
		return name, "bool", false, true
	}
	if argName, ok := parseEnumArg(value); ok {
		if len(enums[fieldType]) == 0 || argName == "" {
			return "", "", false, false
		}
		return argName, enumSchemaForType(fieldType, enums), true, true
	}
	return "", "", false, false
}

func parseEnumArg(value string) (string, bool) {
	if strings.HasPrefix(value, "$enum(") && strings.HasSuffix(value, ")") {
		name := strings.TrimSuffix(strings.TrimPrefix(value, "$enum("), ")")
		return strings.TrimSpace(name), true
	}
	return "", false
}

func enumSchemaForType(typeName string, enums map[string][]enumValueMeta) string {
	values := enums[typeName]
	literals := make([]string, 0, len(values))
	for _, value := range values {
		literals = append(literals, value.Literal)
	}
	return "enum:" + strings.Join(literals, "|")
}

func enumLiteral(typeName, constName string) string {
	suffix := strings.TrimPrefix(constName, typeName)
	if suffix == "" {
		suffix = constName
	}
	switch suffix {
	case "Destination":
		return "onto"
	case "Descendants":
		return "source"
	}
	var out []rune
	for i, r := range suffix {
		if unicode.IsUpper(r) && i > 0 {
			out = append(out, '_')
		}
		out = append(out, unicode.ToLower(r))
	}
	return string(out)
}

func sortedEnumTypesUsedByRules(rules []bindRule, intents map[string]intentTypeMeta, enums map[string][]enumValueMeta) []string {
	seen := map[string]struct{}{}
	var out []string
	for _, rule := range rules {
		intent, ok := intents[rule.Intent]
		if !ok {
			continue
		}
		for field, value := range rule.Set {
			if _, ok := parseEnumArg(value); !ok {
				continue
			}
			fieldType := intent.Fields[field]
			if len(enums[fieldType]) == 0 {
				continue
			}
			if _, ok := seen[fieldType]; ok {
				continue
			}
			seen[fieldType] = struct{}{}
			out = append(out, fieldType)
		}
	}
	sort.Strings(out)
	return out
}

func rulesByOwner(rules []bindRule) map[string][]bindRule {
	byOwner := map[string][]bindRule{}
	for _, r := range rules {
		byOwner[r.Owner] = append(byOwner[r.Owner], r)
	}
	for owner := range byOwner {
		sort.Slice(byOwner[owner], func(i, j int) bool {
			return byOwner[owner][i].Action < byOwner[owner][j].Action
		})
	}
	return byOwner
}

func buildIntentExpr(rule bindRule, intents map[string]intentTypeMeta, enums map[string][]enumValueMeta) string {
	if len(rule.Set) == 0 {
		return fmt.Sprintf("intents.%s{}", rule.Intent)
	}
	intent := intents[rule.Intent]
	fields := make([]string, 0, len(rule.Set))
	for field := range rule.Set {
		fields = append(fields, field)
	}
	sort.Strings(fields)
	parts := make([]string, 0, len(fields))
	for _, field := range fields {
		parts = append(parts, fmt.Sprintf("%s: %s", field, renderValue(intent.Fields[field], rule.Set[field], enums)))
	}
	return fmt.Sprintf("intents.%s{%s}", rule.Intent, strings.Join(parts, ", "))
}

func renderValue(fieldType, value string, enums map[string][]enumValueMeta) string {
	if strings.HasPrefix(value, "$bool(") && strings.HasSuffix(value, ")") {
		name := strings.TrimSuffix(strings.TrimPrefix(value, "$bool("), ")")
		return fmt.Sprintf("actionargs.BoolArg(args, %q, false)", name)
	}
	if argName, ok := parseEnumArg(value); ok && len(enums[fieldType]) > 0 {
		return fmt.Sprintf("enumArg%s(args, %q)", toCamel(fieldType), argName)
	}
	if value == "true" || value == "false" {
		return value
	}
	if _, err := strconv.Atoi(value); err == nil {
		return value
	}
	if strings.HasPrefix(value, "\"") && strings.HasSuffix(value, "\"") {
		return value
	}
	if isIdentifier(value) {
		return "intents." + value
	}
	panic("unsupported set value: " + value)
}

func rulesUseBoolArgs(rules []bindRule) bool {
	for _, rule := range rules {
		for _, value := range rule.Set {
			if strings.HasPrefix(value, "$bool(") && strings.HasSuffix(value, ")") {
				return true
			}
		}
	}
	return false
}

func isIdentifier(s string) bool {
	if s == "" {
		return false
	}
	for i, r := range s {
		if i == 0 {
			if !(unicode.IsLetter(r) || r == '_') {
				return false
			}
			continue
		}
		if !(unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_') {
			return false
		}
	}
	return true
}

func uniqueOwners(rules []bindRule) []string {
	seen := map[string]struct{}{}
	owners := make([]string, 0, len(rules))
	for _, r := range rules {
		if _, ok := seen[r.Owner]; ok {
			continue
		}
		seen[r.Owner] = struct{}{}
		owners = append(owners, r.Owner)
	}
	sort.Strings(owners)
	return owners
}

func revisionsOwnerList(owners []string) []string {
	out := make([]string, 0, len(owners))
	for _, owner := range owners {
		if isRevisionsOwner(owner) {
			out = append(out, owner)
		}
	}
	sort.Strings(out)
	return out
}

func isRevisionsOwner(owner string) bool {
	switch owner {
	case "bookmarks", "choose", "diff", "file_search", "git", "input", "oplog", "password", "redo", "revset", "status.input", "ui", "ui.preview", "undo":
		return false
	}
	return true
}

func ownerConst(owner string) string {
	parts := strings.Split(owner, ".")
	if len(parts) > 1 && parts[0] == "revisions" {
		parts = parts[1:]
	}
	for i := range parts {
		parts[i] = toCamel(parts[i])
	}
	return "Owner" + strings.Join(parts, "")
}

func actionConst(action string) string {
	action = strings.ReplaceAll(action, ".", "_")
	return toCamel(action)
}

func toCamel(s string) string {
	s = filepath.Base(s)
	parts := strings.Split(s, "_")
	for i := range parts {
		if parts[i] == "" {
			continue
		}
		parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
	}
	return strings.Join(parts, "")
}
